{
  "address": "0x1f8ba5874D8719AAC7Fe79aF12BCF7b0b02c4123",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "_entryPoint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "SenderNotExisted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "SenderNotWhitelisted",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "onBehlafOf",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "gas",
          "type": "uint256"
        }
      ],
      "name": "Accepted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "WhitelistedSenderAddressAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "WhitelistedSenderAddressRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "WhitelistedTargetAddressAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "WhitelistedTargetAddressRemoved",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "unstakeDelaySec",
          "type": "uint32"
        }
      ],
      "name": "addStake",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "entryPoint",
      "outputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "isWhitelistedSender",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "isWhitelistedTarget",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IPaymaster.PostOpMode",
          "name": "mode",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "actualGasCost",
          "type": "uint256"
        }
      ],
      "name": "postOp",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "senderWhitelist",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "_entryPoint",
          "type": "address"
        }
      ],
      "name": "setEntryPoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "targetWhitelist",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unlockStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "validatePaymasterUserOp",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "validationData",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "whitelistSender",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "whitelistTarget",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "withdrawAddress",
          "type": "address"
        }
      ],
      "name": "withdrawStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "withdrawAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xcc966c8686457a1b0c1c9350f0eea21b869cfb13965d9db19996af6bd753d7a5",
  "receipt": {
    "to": null,
    "from": "0x1639805FBbC9c5039bc56BA516f396B73b480a23",
    "contractAddress": "0x1f8ba5874D8719AAC7Fe79aF12BCF7b0b02c4123",
    "transactionIndex": 0,
    "gasUsed": "626782",
    "logsBloom": "0x04000000000000400000000000000000000000000000000000800010000000000000000000000020000000000000000000008000000000000000000000000000000000000000000000000000000000800001000000000000000100000000000000000000020000000000000000000800000000000000000080000000010000400000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000010000000000000000004000000000000000000001000000000000000000000000000000100000001020000200000000000000000000000000000000000020000000000000000000100000",
    "blockHash": "0xb0e4d7896c8dc9027f47f5eec507fa1d76156e0440f42d13f5edd3e312c198c6",
    "transactionHash": "0xcc966c8686457a1b0c1c9350f0eea21b869cfb13965d9db19996af6bd753d7a5",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 46053174,
        "transactionHash": "0xcc966c8686457a1b0c1c9350f0eea21b869cfb13965d9db19996af6bd753d7a5",
        "address": "0x1f8ba5874D8719AAC7Fe79aF12BCF7b0b02c4123",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000001639805fbbc9c5039bc56ba516f396b73b480a23"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xb0e4d7896c8dc9027f47f5eec507fa1d76156e0440f42d13f5edd3e312c198c6"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 46053174,
        "transactionHash": "0xcc966c8686457a1b0c1c9350f0eea21b869cfb13965d9db19996af6bd753d7a5",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000001639805fbbc9c5039bc56ba516f396b73b480a23",
          "0x000000000000000000000000f903ba9e006193c1527bfbe65fe2123704ea3f99"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000043a1b4d5726fca000000000000000000000000000000000000000000000000035455496e3d9018000000000000000000000000000000000000000000001332af85276e7baf4ec80000000000000000000000000000000000000000000000000310b39498cb204e000000000000000000000000000000000000000000001332afc8c9235121be92",
        "logIndex": 1,
        "blockHash": "0xb0e4d7896c8dc9027f47f5eec507fa1d76156e0440f42d13f5edd3e312c198c6"
      }
    ],
    "blockNumber": 46053174,
    "cumulativeGasUsed": "626782",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"
  ],
  "numDeployments": 1,
  "solcInputHash": "a56bc86e7b8b5dd3e0e0e2578067c794",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SenderNotExisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"SenderNotWhitelisted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehlafOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"Accepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedSenderAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedSenderAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedTargetAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedTargetAddressRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"}],\"name\":\"addStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"isWhitelistedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isWhitelistedTarget\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPaymaster.PostOpMode\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"}],\"name\":\"postOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"senderWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"name\":\"setEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"targetWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatePaymasterUserOp\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"validationData\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"whitelistSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"whitelistTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addStake(uint32)\":{\"params\":{\"unstakeDelaySec\":\"- the unstake delay for this paymaster. Can only be increased.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"postOp(uint8,bytes,uint256)\":{\"params\":{\"actualGasCost\":\"- actual gas used so far (without this postOp call).\",\"context\":\"- the context value returned by validatePaymasterUserOp\",\"mode\":\"enum with the following options:      opSucceeded - user operation succeeded.      opReverted  - user op reverted. still has to pay for gas.      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.                       Now this is the 2nd call, after user's op was deliberately reverted.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"withdrawStake(address)\":{\"params\":{\"withdrawAddress\":\"the address to send withdrawn value.\"}},\"withdrawTo(address,uint256)\":{\"params\":{\"amount\":\"to withdraw\",\"withdrawAddress\":\"target to send to\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addStake(uint32)\":{\"notice\":\"add stake for this paymaster. This method can also carry eth value to add to the current stake.\"},\"deposit()\":{\"notice\":\"add a deposit for this paymaster, used for paying for transaction fees\"},\"getDeposit()\":{\"notice\":\"return current paymaster's deposit on the entryPoint.\"},\"postOp(uint8,bytes,uint256)\":{\"notice\":\"post-operation handler. Must verify sender is the entryPoint\"},\"unlockStake()\":{\"notice\":\"unlock the stake, in order to withdraw it. The paymaster can't serve requests once unlocked, until it calls addStake again\"},\"withdrawStake(address)\":{\"notice\":\"withdraw the entire paymaster's stake. stake must be unlocked first (and then wait for the unstakeDelay to be over)\"},\"withdrawTo(address,uint256)\":{\"notice\":\"withdraw value from the deposit\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/accountAbstraction/Paymaster.sol\":\"Paymaster\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa92e4fa126feb6907daa0513ddd816b2eb91f30a808de54f63c17d0e162c3439\",\"license\":\"MIT\"},\"contracts/accountAbstraction/Paymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./core/BasePaymaster.sol\\\";\\nimport \\\"./interfaces/IWhitelistPaymaster.sol\\\";\\n\\n\\ncontract Paymaster is IWhitelistPaymaster, BasePaymaster {\\n    mapping(address => bool) public senderWhitelist;\\n    mapping(address => bool) public targetWhitelist;\\n\\n    error SenderNotExisted();\\n    error SenderNotWhitelisted(address);\\n\\n    constructor(IEntryPoint _entryPoint) BasePaymaster(_entryPoint) { }\\n\\n    function whitelistSender(address sender) external override onlyOwner {\\n        senderWhitelist[sender] = true;\\n        emit WhitelistedSenderAddressAdded(sender);\\n    }\\n\\n    function whitelistTarget(address target) external override onlyOwner {\\n        targetWhitelist[target] = true;\\n        emit WhitelistedTargetAddressAdded(target);\\n    }\\n\\n    function isWhitelistedTarget(address target) external view override returns (bool) {\\n        return targetWhitelist[target];\\n    }\\n\\n    function isWhitelistedSender(address sender) external view override returns (bool) {\\n        return senderWhitelist[sender];\\n    }\\n\\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 /*requiredPreFund*/) external view override returns (bytes memory context, uint256 validationData) {\\n        if (userOp.sender.code.length == 0) {\\n            revert SenderNotExisted();\\n        }\\n\\n        if (!senderWhitelist[userOp.sender]) {\\n            revert SenderNotWhitelisted(userOp.sender);\\n        }\\n\\n        return (new bytes(0), 0);\\n    }\\n}\\n\",\"keccak256\":\"0x05bf1d30a4a2ce8a3820cdd47d7990a9dec4f3f44064296d625eb0a639e8d058\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/core/BasePaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\n\\n/* solhint-disable reason-string */\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IPaymaster.sol\\\";\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\n\\n/**\\n * Helper class for creating a paymaster.\\n * provides helper methods for staking.\\n * validates that the postOp is called only by the entryPoint\\n */\\nabstract contract BasePaymaster is IPaymaster, Ownable {\\n\\n    IEntryPoint public entryPoint;\\n\\n    constructor(IEntryPoint _entryPoint) {\\n        setEntryPoint(_entryPoint);\\n    }\\n\\n    function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\\n        entryPoint = _entryPoint;\\n    }\\n\\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\\n    external virtual override returns (bytes memory context, uint256 deadline);\\n\\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external override {\\n        _requireFromEntryPoint();\\n        _postOp(mode, context, actualGasCost);\\n    }\\n\\n    /**\\n     * post-operation handler.\\n     * (verified to be called only through the entryPoint)\\n     * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\\n     * @param mode enum with the following options:\\n     *      opSucceeded - user operation succeeded.\\n     *      opReverted  - user op reverted. still has to pay for gas.\\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n     * @param context - the context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - actual gas used so far (without this postOp call).\\n     */\\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal virtual {\\n\\n        (mode,context,actualGasCost); // unused params\\n        // subclass must override this method if validatePaymasterUserOp returns a context\\n        revert(\\\"must override\\\");\\n    }\\n\\n    /**\\n     * add a deposit for this paymaster, used for paying for transaction fees\\n     */\\n    function deposit() public payable {\\n        entryPoint.depositTo{value : msg.value}(address(this));\\n    }\\n\\n    /**\\n     * withdraw value from the deposit\\n     * @param withdrawAddress target to send to\\n     * @param amount to withdraw\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\\n        entryPoint.withdrawTo(withdrawAddress, amount);\\n    }\\n    /**\\n     * add stake for this paymaster.\\n     * This method can also carry eth value to add to the current stake.\\n     * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\\n     */\\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\\n        entryPoint.addStake{value : msg.value}(unstakeDelaySec);\\n    }\\n\\n    /**\\n     * return current paymaster's deposit on the entryPoint.\\n     */\\n    function getDeposit() public view returns (uint256) {\\n        return entryPoint.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * unlock the stake, in order to withdraw it.\\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\\n     */\\n    function unlockStake() external onlyOwner {\\n        entryPoint.unlockStake();\\n    }\\n\\n    /**\\n     * withdraw the entire paymaster's stake.\\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\\n        entryPoint.withdrawStake(withdrawAddress);\\n    }\\n\\n    /// validate the call is made from a valid entrypoint\\n    function _requireFromEntryPoint() internal virtual {\\n        require(msg.sender == address(entryPoint));\\n    }\\n}\\n\",\"keccak256\":\"0x89702db427de49815cd53bdae71053afafc903cff6af643312d2dcd098ea6165\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(UserOperation calldata userOp)\\n    external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0x30c9af854222af79194396a3d88d122852219bbf84ce35a559e3458ed29e91e7\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo);\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\\n}\",\"keccak256\":\"0x047b592fb80873377bacb3deca4a754ba7f205ccd7701a82d1c6b31908fe41cd\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\",\"keccak256\":\"0x765845e8c8fccce1128a82561f670138fa7bd05230b6bc5b94f0323c05b3b7e6\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/interfaces/IPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n\\n    /**\\n     * payment validation: check if paymaster agree to pay.\\n     * Must verify sender is the entryPoint.\\n     * Revert to reject this request.\\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n     * @param userOp the user operation\\n     * @param userOpHash hash of the user's request data.\\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n     * @return context value to send to a postOp\\n     *  zero length to signify postOp is not required.\\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\\n    external returns (bytes memory context, uint256 deadline);\\n\\n    /**\\n     * post-operation handler.\\n     * Must verify sender is the entryPoint\\n     * @param mode enum with the following options:\\n     *      opSucceeded - user operation succeeded.\\n     *      opReverted  - user op reverted. still has to pay for gas.\\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n     * @param context - the context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - actual gas used so far (without this postOp call).\\n     */\\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\\n\\n    enum PostOpMode {\\n        opSucceeded, // user op succeeded\\n        opReverted, // user op reverted. still has to pay for gas.\\n        postOpReverted //user op succeeded, but caused postOp to revert. Now its a 2nd call, after user's op was deliberately reverted.\\n    }\\n}\\n\",\"keccak256\":\"0x717106f07965b8615c8403509e02079561c73c0222f29bad4cfe4df5dfb8a0bb\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n\\n    event Deposited(\\n        address indexed account,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(\\n        address indexed account,\\n        uint256 withdrawTime\\n    );\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\",\"keccak256\":\"0x46a71b0ea9b8d3505ec3b21b0819b37f39723802f9d0482c18754a3bfd6b0d81\",\"license\":\"GPL-3.0-only\"},\"contracts/accountAbstraction/interfaces/IWhitelistPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\ninterface IWhitelistPaymaster {\\n    event WhitelistedSenderAddressAdded(address addr);\\n    event WhitelistedSenderAddressRemoved(address addr);\\n\\n    event WhitelistedTargetAddressAdded(address addr);\\n    event WhitelistedTargetAddressRemoved(address addr);\\n\\n    event Accepted(address indexed onBehlafOf, address indexed to, uint256 gas);\\n\\n    function whitelistSender(address) external;\\n    function whitelistTarget(address) external;\\n\\n    function isWhitelistedTarget(address target) external view returns (bool);\\n    function isWhitelistedSender(address sender) external view returns (bool);\\n}\",\"keccak256\":\"0x07743f653597717cd4215391e6d99ee8bb35f5fe13d3b3df0cfa6a709aee75c5\",\"license\":\"GPL-3.0\"},\"contracts/accountAbstraction/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.18;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n    /**\\n     * User Operation struct\\n     * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        //lighter signature scheme. must match UserOp.ts#packUserOp\\n        bytes calldata sig = userOp.signature;\\n        // copy directly the userOp from calldata up to (but not including) the signature.\\n        // this encoding depends on the ABI encoding of calldata, but is much lighter to copy\\n        // than referencing each field separately.\\n        assembly {\\n            let ofs := userOp\\n            let len := sub(sub(sig.offset, ofs), 32)\\n            ret := mload(0x40)\\n            mstore(0x40, add(ret, add(len, 32)))\\n            mstore(ret, len)\\n            calldatacopy(add(ret, 32), ofs, len)\\n        }\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x123583323647831d4e429989aa644153de38181edd73a7307d0716dac5bfc14c\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x6080346100a557601f610a3b38819003918201601f19168301916001600160401b038311848410176100aa578084926020946040528339810103126100a557516001600160a01b03808216918290036100a55760005460018060a01b03199133838316176000553391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3600154161760015560405161097a90816100c18239f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6040608081526004908136101561001557600080fd5b600090813560e01c80630396cb60146108215780631b9e2fad146105ef5780631cfda9fa146107b0578063205c2878146107425780632f10a6c6146106d1578063584465f214610688578063715018a61461062e5780638222f07d146105ef578063858437b0146105895780638da5cb5b146105c8578063907caa0014610589578063a9a23409146104f2578063b0d691fe146104ca578063bb9fe6bf14610474578063c23a5cea14610409578063c399ec8814610358578063d0e30db0146102e7578063f2fde38b146102125763f465c77e146100f257600080fd5b346102075760609060031992828436011261020f5784359367ffffffffffffffff9081861161020b576101609086880196360301126102075761013485610906565b3b156101f7576001600160a01b038061014c87610906565b1683526020956002875260ff8585205416156101d5575050825195858701918211878310176101c05750825280855281519382855285518093860152815b8381106101ad57508483018401829052840152601f01601f191682018290030190f35b868101820151868201860152810161018a565b604190634e487b7160e01b6000525260246000fd5b876024926101e38793610906565b925163bf3f938960e01b8152921690820152fd5b825163817206af60e01b81528690fd5b5080fd5b8280fd5b80fd5b5082903461020b57602036600319011261020b576001600160a01b038235818116939192908490036102e3576102466108ae565b8315610291575050600054826bffffffffffffffffffffffff60a01b821617600055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b8480fd5b5091819282600319360112610354576001546001600160a01b031691823b1561034f578390602483518095819363b760faf960e01b8352309083015234905af190811561034657506103365750f35b61033f9061091a565b61020f5780f35b513d84823e3d90fd5b505050fd5b5050fd5b5082903461020b578260031936011261020b5760015481516370a0823160e01b8152308482015290602090829060249082906001600160a01b03165afa9283156103ff5784936103ad575b6020848451908152f35b909192506020903d82116103f7575b601f8201601f191683019067ffffffffffffffff8211848310176101c05750602091839185528101031261020b5760209250519083806103a3565b3d91506103bc565b82513d86823e3d90fd5b509181923461035457602036600319011261035457610426610893565b61042e6108ae565b6001546001600160a01b03908116803b15610470578592836024928651978895869463611d2e7560e11b865216908401525af190811561034657506103365750f35b8580fd5b50918192346103545782600319360112610354576104906108ae565b6001546001600160a01b031691823b1561034f57815163bb9fe6bf60e01b81529284918491829084905af190811561034657506103365750f35b503461020757816003193601126102075760015490516001600160a01b039091168152602090f35b5091903461020f57606036600319011261020f5760038235101561020f5760243567ffffffffffffffff80821161020b573660238301121561020b578184013590811161020b573691016024011161020f576001546001600160a01b0316330361020f57506020606492519162461bcd60e51b8352820152600d60248201526c6d757374206f7665727269646560981b6044820152fd5b50823461020b57602036600319011261020b57356001600160a01b0381169081900361020b57818360ff92602095526003855220541690519015158152f35b5034610207578160031936011261020757905490516001600160a01b039091168152602090f35b50823461020b57602036600319011261020b57356001600160a01b0381169081900361020b57818360ff92602095526002855220541690519015158152f35b823461020f578060031936011261020f576106476108ae565b600080546001600160a01b0319811682556001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b82843461020757602036600319011261020757356001600160a01b03811690819003610207576106b66108ae565b6bffffffffffffffffffffffff60a01b600154161760015580f35b50823461020b57602036600319011261020b57356001600160a01b038116919082900361020b577fb65748ca52f895b457808c4dfa30c1cb1c28ca296d55794426b00c7a5360b916916020916107256108ae565b81855260028352808520805460ff1916600117905551908152a180f35b509181923461035457806003193601126103545761075e610893565b6107666108ae565b6001546001600160a01b03908116803b15610470578592836044928651978895869463040b850f60e31b8652169084015260243560248401525af190811561034657506103365750f35b50823461020b57602036600319011261020b57356001600160a01b038116919082900361020b577fb247c6bc9b15399c4e26c64254ec9e9a0d897aaa8360bc962845e2ee079d2cd5916020916108046108ae565b81855260038352808520805460ff1916600117905551908152a180f35b508290602036600319011261020b5782823563ffffffff8116809103610207576108496108ae565b6001546001600160a01b031693843b1561020b5760249084519586938492621cb65b60e51b845283015234905af19081156103465750610887575080f35b6108909061091a565b80f35b600435906001600160a01b03821682036108a957565b600080fd5b6000546001600160a01b031633036108c257565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b356001600160a01b03811681036108a95790565b67ffffffffffffffff811161092e57604052565b634e487b7160e01b600052604160045260246000fdfea264697066735822122061e3b888549c7378225b0a80074b4067ef8b15c050ba3b2a5eae969f02b553ef64736f6c63430008120033",
  "deployedBytecode": "0x6040608081526004908136101561001557600080fd5b600090813560e01c80630396cb60146108215780631b9e2fad146105ef5780631cfda9fa146107b0578063205c2878146107425780632f10a6c6146106d1578063584465f214610688578063715018a61461062e5780638222f07d146105ef578063858437b0146105895780638da5cb5b146105c8578063907caa0014610589578063a9a23409146104f2578063b0d691fe146104ca578063bb9fe6bf14610474578063c23a5cea14610409578063c399ec8814610358578063d0e30db0146102e7578063f2fde38b146102125763f465c77e146100f257600080fd5b346102075760609060031992828436011261020f5784359367ffffffffffffffff9081861161020b576101609086880196360301126102075761013485610906565b3b156101f7576001600160a01b038061014c87610906565b1683526020956002875260ff8585205416156101d5575050825195858701918211878310176101c05750825280855281519382855285518093860152815b8381106101ad57508483018401829052840152601f01601f191682018290030190f35b868101820151868201860152810161018a565b604190634e487b7160e01b6000525260246000fd5b876024926101e38793610906565b925163bf3f938960e01b8152921690820152fd5b825163817206af60e01b81528690fd5b5080fd5b8280fd5b80fd5b5082903461020b57602036600319011261020b576001600160a01b038235818116939192908490036102e3576102466108ae565b8315610291575050600054826bffffffffffffffffffffffff60a01b821617600055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b8480fd5b5091819282600319360112610354576001546001600160a01b031691823b1561034f578390602483518095819363b760faf960e01b8352309083015234905af190811561034657506103365750f35b61033f9061091a565b61020f5780f35b513d84823e3d90fd5b505050fd5b5050fd5b5082903461020b578260031936011261020b5760015481516370a0823160e01b8152308482015290602090829060249082906001600160a01b03165afa9283156103ff5784936103ad575b6020848451908152f35b909192506020903d82116103f7575b601f8201601f191683019067ffffffffffffffff8211848310176101c05750602091839185528101031261020b5760209250519083806103a3565b3d91506103bc565b82513d86823e3d90fd5b509181923461035457602036600319011261035457610426610893565b61042e6108ae565b6001546001600160a01b03908116803b15610470578592836024928651978895869463611d2e7560e11b865216908401525af190811561034657506103365750f35b8580fd5b50918192346103545782600319360112610354576104906108ae565b6001546001600160a01b031691823b1561034f57815163bb9fe6bf60e01b81529284918491829084905af190811561034657506103365750f35b503461020757816003193601126102075760015490516001600160a01b039091168152602090f35b5091903461020f57606036600319011261020f5760038235101561020f5760243567ffffffffffffffff80821161020b573660238301121561020b578184013590811161020b573691016024011161020f576001546001600160a01b0316330361020f57506020606492519162461bcd60e51b8352820152600d60248201526c6d757374206f7665727269646560981b6044820152fd5b50823461020b57602036600319011261020b57356001600160a01b0381169081900361020b57818360ff92602095526003855220541690519015158152f35b5034610207578160031936011261020757905490516001600160a01b039091168152602090f35b50823461020b57602036600319011261020b57356001600160a01b0381169081900361020b57818360ff92602095526002855220541690519015158152f35b823461020f578060031936011261020f576106476108ae565b600080546001600160a01b0319811682556001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b82843461020757602036600319011261020757356001600160a01b03811690819003610207576106b66108ae565b6bffffffffffffffffffffffff60a01b600154161760015580f35b50823461020b57602036600319011261020b57356001600160a01b038116919082900361020b577fb65748ca52f895b457808c4dfa30c1cb1c28ca296d55794426b00c7a5360b916916020916107256108ae565b81855260028352808520805460ff1916600117905551908152a180f35b509181923461035457806003193601126103545761075e610893565b6107666108ae565b6001546001600160a01b03908116803b15610470578592836044928651978895869463040b850f60e31b8652169084015260243560248401525af190811561034657506103365750f35b50823461020b57602036600319011261020b57356001600160a01b038116919082900361020b577fb247c6bc9b15399c4e26c64254ec9e9a0d897aaa8360bc962845e2ee079d2cd5916020916108046108ae565b81855260038352808520805460ff1916600117905551908152a180f35b508290602036600319011261020b5782823563ffffffff8116809103610207576108496108ae565b6001546001600160a01b031693843b1561020b5760249084519586938492621cb65b60e51b845283015234905af19081156103465750610887575080f35b6108909061091a565b80f35b600435906001600160a01b03821682036108a957565b600080fd5b6000546001600160a01b031633036108c257565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b356001600160a01b03811681036108a95790565b67ffffffffffffffff811161092e57604052565b634e487b7160e01b600052604160045260246000fdfea264697066735822122061e3b888549c7378225b0a80074b4067ef8b15c050ba3b2a5eae969f02b553ef64736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addStake(uint32)": {
        "params": {
          "unstakeDelaySec": "- the unstake delay for this paymaster. Can only be increased."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "postOp(uint8,bytes,uint256)": {
        "params": {
          "actualGasCost": "- actual gas used so far (without this postOp call).",
          "context": "- the context value returned by validatePaymasterUserOp",
          "mode": "enum with the following options:      opSucceeded - user operation succeeded.      opReverted  - user op reverted. still has to pay for gas.      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.                       Now this is the 2nd call, after user's op was deliberately reverted."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "withdrawStake(address)": {
        "params": {
          "withdrawAddress": "the address to send withdrawn value."
        }
      },
      "withdrawTo(address,uint256)": {
        "params": {
          "amount": "to withdraw",
          "withdrawAddress": "target to send to"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addStake(uint32)": {
        "notice": "add stake for this paymaster. This method can also carry eth value to add to the current stake."
      },
      "deposit()": {
        "notice": "add a deposit for this paymaster, used for paying for transaction fees"
      },
      "getDeposit()": {
        "notice": "return current paymaster's deposit on the entryPoint."
      },
      "postOp(uint8,bytes,uint256)": {
        "notice": "post-operation handler. Must verify sender is the entryPoint"
      },
      "unlockStake()": {
        "notice": "unlock the stake, in order to withdraw it. The paymaster can't serve requests once unlocked, until it calls addStake again"
      },
      "withdrawStake(address)": {
        "notice": "withdraw the entire paymaster's stake. stake must be unlocked first (and then wait for the unstakeDelay to be over)"
      },
      "withdrawTo(address,uint256)": {
        "notice": "withdraw value from the deposit"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4944,
        "contract": "contracts/accountAbstraction/Paymaster.sol:Paymaster",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 14138,
        "contract": "contracts/accountAbstraction/Paymaster.sol:Paymaster",
        "label": "entryPoint",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IEntryPoint)15204"
      },
      {
        "astId": 13845,
        "contract": "contracts/accountAbstraction/Paymaster.sol:Paymaster",
        "label": "senderWhitelist",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 13849,
        "contract": "contracts/accountAbstraction/Paymaster.sol:Paymaster",
        "label": "targetWhitelist",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IEntryPoint)15204": {
        "encoding": "inplace",
        "label": "contract IEntryPoint",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}